\documentclass[a4paper,12pt]{article}

\usepackage{fontspec}
\setmainfont{Times New Roman}
\defaultfontfeatures{Ligatures=TeX}

\usepackage[colorlinks,allcolors=black,urlcolor=blue]{hyperref}
\usepackage[english,russian]{babel}
\usepackage[left=3cm,top=2cm,right=2cm,bottom=2cm]{geometry}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{unicode-math}

\usepackage{enumitem}
\setlist[itemize]{nosep}

\usepackage{minted}
\setminted{baselinestretch=1}

\usepackage[style=alphabetic]{biblatex}
\addbibresource{references.bib}

\renewcommand{\labelitemi}{--}
\linespread{1.25}

\newcommand{\sem}[1]{[\![#1]\!]}

\title{Корректность статического анализа}
\date{}

\begin{document}
\maketitle
Статические анализаторы пытаются автоматически установить некоторые свойства
программ без их выполнения.

Статические анализаторы можно использовать по-разному, например:
\begin{itemize}
\item для поиска ошибок, совершаемых программистами;
\item в качестве верификаторов, гарантирующих соответствие программы
  определенным свойствам.
\end{itemize}

При поиске ошибок анализ должен быть точным (слишком большое количество ложных
срабатываний делает инструмент непригодным), однако не ожидается и не
предоставляется гарантия обнаружения всех ошибок определенного класса. С другой
стороны, при верификации программ \emph{корректность анализа} имеет
первостепенное значение: если анализатор не выдает предупреждений, программа
должна быть свободна от класса отслеживаемых анализатором ошибок.

Наша задача -- разработать корректный статический анализатор для простого
императивного языка программирования. Для этого мы будем использовать
абстрактную интерпретацию, а доказательство корректности осуществлять с помощью
Rocq.

\section*{Абстрактная интерпретация на примере}
\label{sec:example}

Абстрактная интерпретация -- это способ корректной аппроксимации семантики языка
программирования. Необходимость аппроксимации объясняется неразрешимостью
анализа семантических свойств
программ\footnote{\url{https://en.wikipedia.org/wiki/Rice's_theorem}}. При
аппроксимации:
\begin{itemize}
\item конкретные значения переменных заменяются абстрактными;
\item конкретная семантика заменяется на семантику, работающую с этими
  абстрактными значениями.
\end{itemize}

Например, рассмотрим следующую простую программу:

\begin{center}
  \begin{minipage}{0.2\textwidth}
    \begin{minted}{pascal}
if x > 0 then
  y := x + 1
else
  y := 1
x := x / y
    \end{minted}
  \end{minipage}
\end{center}

Добавим к программе аннотации, в которых показано ее состояние. На
рисунке~\ref{fig:annot}.а приведены конкретные значения переменных для случая,
когда выполнение программы начинается в состоянии, где $x = 10, y = 0$. На
рисунке~\ref{fig:annot}.б конкретные значения заменяются интервалами, что
позволяет перейти от одного конкретного выполнения программы к абстрактному
выполнению программы на всех возможных значениях переменных.

\begin{figure}[htbp!]
  \centering
  \begin{minipage}{0.4\textwidth}
    \begin{minted}[mathescape]{pascal}
{ $x = 10, y = 0$ }
if x > 0 then
  { $x = 10, y = 1$ }
  y := x + 1
  { $x = 10, y = 11$ }
else
  { }
  y := 1
  { }
{ $x = 10, y = 11$ }
x := x / y
{ $x = 0, y = 11$ }
    \end{minted}
  \end{minipage}
  \centering
  \begin{minipage}{0.4\textwidth}
    \begin{minted}[mathescape]{pascal}
{ $x \in [-\infty, +\infty], y \in [-\infty, +\infty]$ }
if x > 0 then
  { $x \in [1, +\infty], y \in [-\infty, +\infty]$ }
  y := x + 1
  { $x \in [1, +\infty], y \in [2, +\infty]$ }
else
  { $x \in [-\infty, 0], y \in [-\infty, +\infty]$ }
  y := 1
  { $x \in [-\infty, 0], y \in [1, 1]$ }
{ $x \in [-\infty, +\infty], y \in [1, +\infty]$ }
x := x / y
{ $x \in [-\infty, +\infty], y \in [1, +\infty]$ }
    \end{minted}
  \end{minipage}
  \caption{Выполнение программы а) на конкретных значениях, б) на абстрактных
    значениях.}
  \label{fig:annot}
\end{figure}

Перед выполнением операции деления на абстрактных значениях мы видим, что
переменная $y \in [1, +\infty]$ и не может принимать нулевое
значение. Полученная аппроксимация является корректной, т.к. абстрактные
значения содержат все возможные конкретные значения. Это позволяет утверждать,
что выполнение операции не приводит к ошибке деления на 0 для любого конкретного
выполнения программы.

\section*{Корректность абстрактной интерпретации}
\label{sec:soundness}

Перейдем от наглядных примеров к формальным определениям.

\emph{Абстрактные значения} должны обладать:
\begin{itemize}
\item структурой решетки;
\item отображением конкретизации, связывающим абстрактные значения с
  конкретными;
\item абстрактными операциями, соответствующими конкретным операциям языка
  программирования.
\end{itemize}

% \emph{Отношением порядка} называется \dots

% Множество с отношением порядка на нем называется \emph{частично упорядоченным}.

\emph{Решеткой} называется частично упорядоченное множество, в котором любое
конечное подмножество обладает точной верхней и точной нижней гранями.

\emph{Отображением конкретизации} называется монотонное отображение
$\gamma : A \to \mscrP C$ из абстрактного домена в подмножества значений
конкретного.

% Условие монотонности означает, что \dots

\emph{Абстрактное состояние} -- это конечное отображение переменных в
абстрактные значения.

\textbf{Задание 1}. Определите операции решетки на абстрактных состояниях с
помощью операций решетки на абстрактных значениях. Затем, покажите, что на
абстрактном состоянии определено отображение конкретизации, индуцированное
отображением конкретизации на абстрактных значениях (в файле \texttt{AbsInt.v}
закончите определения \texttt{astateLatti\-ceOp} и
\texttt{astateConcre\-tization}).

Структура решетки на абстрактных состояниях позволяет задать абстрактную
семантику. В частности, существование точной верхней грани позволяет определить
семантику условного оператора, а существование неподвижной точки у монотонного
отображения на решетке -- определить семантику циклического оператора:
\begin{align*}
\sem{\text{skip}}(S) &= S \\
\sem{x := e}(S) &= S[x \mapsto \sem{e}(S)] \\
\sem{c_1 ; c_2}(S) &= \sem{c_2}(\sem{c_1}(S)) \\
\sem{\text{if } e \text{ then } c_1 \text{ else } c_2}(S) &= \sem{c_1}(S) \vee \sem{c_2}(S) \\
\sem{\text{while } e \text{ do } c}(S) &= \text{postfixpoint}\; \text{of } F(X) = S \vee \sem{c}(X)
\end{align*}

\textbf{Задание 2}. Докажите корректность абстрактной интерпретации: абстрактная
семантика команд аппроксимирует конкретную семантику (в файле
\texttt{Abs\-Int.v} закончите доказательство теоремы \texttt{aceval\_sound}, для
этого сначала нужно доказать корректность определения неподвижной точки, лемма
\texttt{postfixpoint\_sound}, и корректность определения абстрактной семантики
выражений, лемма \texttt{aeval\_sound}).

\section*{Применение: распространение констант}
\label{sec:propagation}

Чтобы воспользоваться, полученным абстрактным интерпретатором нужно определить
абстрактный домен, на котором он будет работать. Рассмотрим задачу
распространения констант (constant propagation), возникающую при компиляции
программ. Этот вариант статического анализа определяет имеет ли переменная
постоянное значение, и передает его в места использования данной переменной,
например, для выполнения дальнейшей свертки констант, уменьшающей избыточные
вычисления. Например, статический анализ следующей программы показывает, что
$y = 12$, а $z = 11$:

\begin{center}
  \begin{minipage}{0.5\textwidth}
    \begin{minted}{pascal}
x := 1; y := 10; z := x + y;
if x > 0 then
  y := x + z; x := 0
else
  y := 12
    \end{minted}
  \end{minipage}
\end{center}

\textbf{Задание 3}. Реализуйте абстрактный домен для задачи распространения
констант (в файле \texttt{AbsInt.v} закончите определения
\texttt{flatZLatticeOp}, \texttt{flatZ\-Concretization} и \texttt{flatZ\-AbsValue}).

\section*{Анализ условий}
\label{sec:conditionals}

Текущий вариант абстрактной интерпретации не проводит анализ условий при
ветвлениях -- абстрактно интерпретируются обе ветви условного оператора,
полученные результаты объединяются:
\begin{align*}
\sem{\text{if } e \text{ then } c_1 \text{ else } c_2}(S) &= \sem{c_1}(S) \vee \sem{c_2}(S)
\end{align*}

Можно улучшить результаты анализа, если добавить информацию о результате
абстрактной интерпретация условия в каждую из ветвей, например:
\begin{align*}
\sem{\text{if } e \text{ then } c_1 \text{ else } c_2}(S) &=
  \sem{c_1}(\text{assume\_true}(e, S)) \vee \sem{c_2}(\text{assume\_false}(e, S)),
\end{align*}
где $\text{assume\_true}(e,S)$ возвращает абстрактное состояние
$S' \leqslant S$, в котором условие $e$ истинно, a $\text{assume\_false}(e,S)$
возвращает $S' \leqslant S$, в котором $e$ ложно.

Аналогичное улучшение можно применить к анализу условий циклов:
\begin{align*}
\sem{\text{while } e \text{ do } c}(S) &=
  \text{assume\_false} (e, \text{postfixpoint}\; \text{of } F(X) = S \vee \sem{c}(\text{assume\_true}(e,X)))
\end{align*}

\textbf{Задание 4}. Реализуйте анализ условий и докажите его
корректность (создайте файл \texttt{AbsIntCond.v}, скопировав файл
\texttt{AbsInt.v}, внесите необходимые изменения).

\section*{Применение: интервалы}
\label{sec:intervals}

\dots

\textbf{Задание 5}. (в файле \texttt{AbsIntCond.v} определите \dots)

\printbibliography
\end{document}
